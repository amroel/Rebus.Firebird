using FirebirdSql.Data.FirebirdClient;
using Rebus.Bus;
using Rebus.Firebird.Internals;
using Rebus.Messages;
using Rebus.Serialization;
using Rebus.Transport;

namespace Rebus.Firebird.FirebirdSql.Outbox;

/// <summary>
/// Outbox implementation that uses a table in Firebird database to store the necessary outbox information
/// </summary>
/// <remarks>
/// Creates the outbox storage
/// </remarks>
public sealed class FirebirdOutboxStorage(Func<ITransactionContext, IDbConnection> connectionProvider,
	string senderAddress,
	TableName tableName)
	: IOutboxStorage, IInitializable
{
	private static readonly HeaderSerializer _headerSerializer = new();
	private readonly Func<ITransactionContext, IDbConnection> _connectionProvider = connectionProvider;
	private readonly TableName _tableName = tableName;
	private readonly string _senderAddress = senderAddress;

	/// <summary>
	/// Initializes the outbox storage
	/// </summary>
	public void Initialize()
	{
		async Task InitializeAsync()
		{
			using RebusTransactionScope scope = new();
			using IDbConnection connection = _connectionProvider(scope.TransactionContext);

			if (connection.TableExists(_tableName))
				return;

			try
			{
				using FbCommand command = connection.CreateCommand();

				command.CommandText = $"""
					create table {_tableName}
					(
					    id bigint generated by default as identity primary key,
						sender_address varchar(255) not null,
					    correlation_id varchar(16),
					    message_id varchar(255),
					    source_queue varchar(255),
					    destination_address varchar(255) not null,
					    headers blob sub_type text,
					    body blob sub_type binary
					)
					""";

				await command.ExecuteNonQueryAsync();

				command.CommandText = $"create index ix_{_tableName}_sender on {_tableName} (sender_address)";
				await command.ExecuteNonQueryAsync();

				await connection.Complete();
			}
			catch (Exception)
			{
				if (!connection.TableExists(_tableName))
				{
					throw;
				}
			}

			await scope.CompleteAsync();
		}

		AsyncHelper.RunSync(InitializeAsync);
	}

	/// <summary>
	/// Stores the given <paramref name="outgoingMessages"/> using the given <paramref name="dbConnection"/>.
	/// </summary>
	public async Task Save(IEnumerable<OutgoingTransportMessage> outgoingMessages, IDbConnection dbConnection)
		=> await SaveUsingConnection(dbConnection, outgoingMessages);

	/// <inheritdoc />
	public async Task<OutboxMessageBatch> GetNextMessageBatch(string? correlationId = null,
		int maxMessageBatchSize = 100) => await InnerGetMessageBatch(maxMessageBatchSize, correlationId);

	private async Task<OutboxMessageBatch> InnerGetMessageBatch(int maxMessageBatchSize, string? correlationId)
	{
		if (maxMessageBatchSize <= 0)
		{
			throw new ArgumentException(
				$"Cannot retrieve {maxMessageBatchSize} messages - please pass in a value >= 1",
				nameof(maxMessageBatchSize));
		}

		// no 'using' here, because this will be passed to the outbox message batch
		RebusTransactionScope scope = new();

		try
		{
			// no 'using' here either, because this will be passed to the outbox message batch
			IDbConnection connection = _connectionProvider(scope.TransactionContext);

			// this must be done when cleaning up
			void Dispose()
			{
				connection.Dispose();
				scope.Dispose();
			}

			try
			{
				List<OutboxMessage> messages = await GetOutboxMessages(connection, maxMessageBatchSize, correlationId);

				// bail out if no messages were found
				if (messages.Count == 0)
					return OutboxMessageBatch.Empty(Dispose);

				// define what it means to complete the batch
				async Task Complete()
				{
					await DeleteMessages(connection, messages);
					await connection.Complete();
					await scope.CompleteAsync();
				}

				return new OutboxMessageBatch(Complete, messages, Dispose);
			}
			catch (Exception)
			{
				connection.Dispose();
				throw;
			}
		}
		catch (Exception)
		{
			scope.Dispose();
			throw;
		}
	}

	private async Task SaveUsingConnection(IDbConnection connection,
		IEnumerable<OutgoingTransportMessage> outgoingMessages)
	{
		using FbCommand command = connection.CreateCommand();
		command.CommandText = $"""
				insert into {_tableName} 
				(
					sender_address,
					correlation_id, 
					message_id, 
					source_queue, 
					destination_address, 
					headers, 
					body
				)
				values 
				(
					@senderAddress,
					@correlationId, 
					@messageId, 
					@sourceQueue, 
					@destinationAddress, 
					@headers, 
					@body
				)
				""";
		command.Parameters.AddWithValue("senderAddress", _senderAddress);
		FbParameter corrParam = command.Parameters.Add("correlationId", FbDbType.VarChar, 16);
		FbParameter msgIdParam = command.Parameters.Add("messageId", FbDbType.Text);
		FbParameter srcParam = command.Parameters.Add("sourceQueue", FbDbType.Text);
		FbParameter adrParam = command.Parameters.Add("destinationAddress", FbDbType.Text);
		FbParameter hdrParam = command.Parameters.Add("headers", FbDbType.Text);
		FbParameter bdyParam = command.Parameters.Add("body", FbDbType.Binary);

		foreach (OutgoingTransportMessage message in outgoingMessages)
		{

			TransportMessage transportMessage = message.TransportMessage;
			var body = message.TransportMessage.Body;
			var headers = SerializeHeaders(transportMessage.Headers);

			msgIdParam.Value = transportMessage.Headers.TryGetValue(Headers.MessageId, out var id) ? id : DBNull.Value;
			corrParam.Value = transportMessage.Headers.TryGetValue(Headers.CorrelationId, out var corId)
				? corId
				: DBNull.Value;
			srcParam.Value = transportMessage.Headers.TryGetValue(Headers.SourceQueue, out var srcQueue)
				? srcQueue
				: DBNull.Value;
			adrParam.Value = message.DestinationAddress;
			hdrParam.Value = headers;
			bdyParam.Value = body;

			await command.ExecuteNonQueryAsync();
		}
	}

	private async Task DeleteMessages(IDbConnection connection, IEnumerable<OutboxMessage> messages)
	{
		using FbCommand command = connection.CreateCommand();

		var idParams = string.Join(", ", messages.Select(m => m.Id));
		command.CommandText = $"delete from {_tableName} where id in ({idParams})";
		var deleted = await command.ExecuteNonQueryAsync();

		await command.ExecuteNonQueryAsync();
	}

	private async Task<List<OutboxMessage>> GetOutboxMessages(IDbConnection connection,
		int maxMessageBatchSize,
		string? correlationId)
	{
		using FbCommand command = connection.CreateCommand();
		var select = $"""
			select
				id, 
				destination_address, 
				headers, 
				body
			from {_tableName}
			where 
				sender_address = @senderAddress			
			""";
		const string orderByForUpdate = """
			order by 
				id asc
			fetch next @maxBatchSize rows only
			for update
			with lock
			""";
		if (correlationId is not null)
		{
			command.CommandText = $"""
				{select}
					and correlation_id = @correlationId
				{orderByForUpdate}
				""";
			command.Parameters.AddWithValue("correlationId", correlationId);
		}
		else
		{
			command.CommandText = $"""
				{select}
				{orderByForUpdate}
				""";
		}
		command.Parameters.AddWithValue("maxBatchSize", maxMessageBatchSize);
		command.Parameters.AddWithValue("senderAddress", _senderAddress);

		using FbDataReader reader = await command.ExecuteReaderAsync();

		List<OutboxMessage> messages = [];

		while (await reader.ReadAsync())
		{
			var id = (long)reader["id"];
			var destinationAddress = (string)reader["destination_address"];
			Dictionary<string, string> headers = _headerSerializer.DeserializeFromString((string)reader["headers"]);
			var body = (byte[])reader["body"];
			messages.Add(new OutboxMessage(id, destinationAddress, headers, body));
		}

		return messages;
	}

	private static string SerializeHeaders(Dictionary<string, string> headers)
		=> _headerSerializer.SerializeToString(headers);
}
